## 배열

- 버블 정렬

  -  인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

  - 시간복잡도 O(n^2)
  - 비교와 교환으로 코딩이 가장 손쉽다.

  ``` python
  # 오름차순 정렬
  def BubbleSort(a, N):	# a : 정렬할 list, N : 원소의 수
  	for i in range(N-1, 0, -1):	# 범위의 끝 위치
          for j in range(0, i):	# 비교할 원소 중 왼쪽 원소의 인덱스
              if a[j] > a[j+1]:	# 왼쪽 원소가 더 크면
                  a[j], a[j+1] = a[j+1], a[j]	# 오른쪽 원소와 교환
  ```



- 카운팅 정렬

  - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
  - 조건 : 정수나 정수로 표현할 수 있는 자료에 대해서만 적용
  - 시간 복잡도 O(n+k) : n = 리스트의 길이, k = 정수의 최댓값
  - 비교환 방식으로 n이 비교적 작을 때만 가능

  ``` python
  def CountingSort(a, b, k):
      # a[] : 입력된 배열 (1 to k)
      # b[] : 정렬된 배열
      # c[] : 카운트 배열
      c = [0] * (k+1)
      
      for i in range(len(a)):	# a 배열에서 각 항목의 발생 회수를 c 배열에 입력
          c[a[i]] += 1
        
      for i in range(1, len(c)):	# 각 항목의 앞에 위치할 항목의 개수 반영하기 위해 앞의 원소를 더해줌 (누적)
          c[i] += c[i-1]
       
      for i in range(len(b)-1, -1, -1):
          c[a[i]] -= 1
          b[c[a[i]]] = a[i]
  ```

  

- 완전 검색 (Exaustive Search)

  - 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
  - Brute-force / generate-and-test 라고도 불림
  - 모든 경우의 수를 테스트 한 후 최종 해법을 도출하므로 경우의 수가 상대적으로 작을 때 유용
  - 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 적다.
  - baby-gin game
  - 단순하게 순열을 생성하는 방법

  ``` python
  # 예 {1, 2, 3}을 포함하는 모든 순열 생성
  for i in range(1, 4):
      for j in range(1, 4):
          if i != j:
              for k in range(1, 4):
                  if k != i and k != j:
                      print(i, j, k)
  ```

  

- 탐욕(Greedy) 알고리즘
  - 여러 경우 중 하나를 결정해야 할 때마다 그 순간에 최적이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
  - 각 선택의 시점에서 이루어지는 결정은 지역적으로는 최적이지만, 그 선택들을 계속 수집하여 최종적인 해답을 만들었다고 하여, 그것이 최적이라는 보장은 없다.
  - 동작 과정
    - 해 선택 : 현재 상태에서 부분 문제의 최적해를 구한 뒤, 이를 부분해 집합에 추가
    - 실행 가능성 검사
    - 해 검사 
  - 거스름돈 줄이기